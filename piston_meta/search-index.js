var searchIndex = {};
searchIndex["piston_meta"] = {"doc":"A DSL parsing library for human readable text documents","items":[[3,"ParseErrorHandler","piston_meta","Reports error.",null,null],[3,"Syntax","","Stores syntax.",null,null],[12,"rules","","Rule data.",0,null],[12,"names","","Name of rules.",0,null],[4,"ParseError","","Errors reporting expected values.",null,null],[13,"ExpectedWhitespace","","Whitespace is required.",1,null],[13,"ExpectedNewLine","","New line is required.",1,null],[13,"ExpectedSomething","","Something is required.",1,null],[13,"ExpectedNumber","","Expected number.",1,null],[13,"ParseNumberError","","Error when parsing float.",1,null],[13,"ExpectedText","","Expected text.",1,null],[13,"EmptyTextNotAllowed","","Empty text not allowed.",1,null],[13,"ParseStringError","","Invalid string format.",1,null],[13,"ExpectedTag","","Expected token.",1,null],[13,"DidNotExpectTag","","Did not expected token.",1,null],[13,"InvalidRule","","An invalid rule.",1,null],[13,"NoRules","","No rules are specified.",1,null],[13,"ExpectedEnd","","Expected to reach the end.",1,null],[13,"Conversion","","Conversion error.",1,null],[4,"Rule","","A rule describes how some section of a document should be parsed.",null,null],[13,"Whitespace","","Read whitespace.",2,null],[13,"Tag","","Match against a tag.",2,null],[13,"UntilAny","","Reads until any character.",2,null],[13,"UntilAnyOrWhitespace","","Read until any character or whitespace.",2,null],[13,"Text","","Read text.",2,null],[13,"Number","","Read number.",2,null],[13,"Select","","Select one of the sub rules.\nIf the first one does not succeed, try another and so on.\nIf all sub rules fail, then the rule fails.",2,null],[13,"Sequence","","Run each sub rule in sequence.\nIf any sub rule fails, the rule fails.",2,null],[13,"SeparateBy","","Repeat rule separated by another rule.",2,null],[13,"Repeat","","Repeat rule.",2,null],[13,"Lines","","Repeat rule separated by one or more lines.",2,null],[13,"Node","","Read node.",2,null],[13,"Optional","","Read optional.",2,null],[4,"MetaData","","Represents meta data.",null,null],[13,"StartNode","","Starts node.",3,null],[13,"EndNode","","Ends node.",3,null],[13,"Bool","","Sets bool property.",3,null],[13,"F64","","Sets f64 property.",3,null],[13,"String","","Sets string property.",3,null],[5,"stderr_unwrap","","When an error happens, reports to standard error and then panics.",null,{"inputs":[{"name":"str"},{"name":"result"}],"output":{"name":"t"}}],[5,"syntax","","Reads syntax from text.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"syntax_errstr","","Reads syntax from text, formatting the error as `String`.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"load_syntax_data","","Convenience method for loading data, using the meta language.\nPanics if there is an error, and writes error message to\nstandard error output.",null,{"inputs":[{"name":"a"},{"name":"b"}],"output":{"name":"vec"}}],[0,"bootstrap","","Bootstrapping meta rules for changing documents at runtime",null,null],[3,"Convert","piston_meta::bootstrap","Stores state when converting from meta data.",null,null],[5,"rules","","Returns rules for parsing meta rules.",null,{"inputs":[],"output":{"name":"syntax"}}],[5,"convert","","Converts meta data to rules.",null,null],[11,"clone","","",4,null],[11,"fmt","","",4,null],[11,"new","","Creates a new `Convert`.",4,null],[11,"remaining_data_len","","Returns the length of remaining data.",4,null],[11,"subtract","","Returns the difference in offset.",4,null],[11,"source","","Returns the subtracted range in source (union of meta data ranges).",4,null],[11,"update","","Updates with parsed range.",4,null],[11,"start_node","","Reads start node.",4,null],[11,"end_node","","Reads end node.",4,null],[11,"ignore","","Ignores next item.\nIf this is the start of a node, it ignores all items to the end node.",4,null],[11,"meta_string","","Reads string.",4,null],[11,"meta_f64","","Reads f64.",4,null],[11,"meta_bool","","Reads bool.",4,null],[0,"json","piston_meta","Write meta data as JSON.",null,null],[5,"write","piston_meta::json","Writes meta data as JSON.",null,null],[5,"write_string","","Writes a JSON string.",null,{"inputs":[{"name":"w"},{"name":"str"}],"output":{"name":"result"}}],[5,"print","","Prints meta data.",null,null],[0,"meta_rules","piston_meta","Building blocks for meta rules.",null,null],[3,"Lines","piston_meta::meta_rules","Stores information about lines.",null,null],[12,"rule","","The rule to read lines.\nThis can be a multi-line rule.",5,null],[12,"debug_id","","A debug id to track down the rule generating an error.",5,null],[3,"Node","","A node reference.",null,null],[12,"name","","Name of rule.",6,null],[12,"property","","The property to set.",6,null],[12,"debug_id","","A debug id to track down the rule generating an error.",6,null],[12,"index","","The index to the rule reference.",6,null],[3,"Number","","Contains information about number.",null,null],[12,"property","","The property to set.",7,null],[12,"debug_id","","A debug id to track down the rule generating an error.",7,null],[12,"allow_underscore","","Whether underscore is allowed as visible separator.",7,null],[3,"Optional","","Stores information about optional.",null,null],[12,"rule","","The optional rule.",8,null],[12,"debug_id","","A debug id to track down the rule generating an error.",8,null],[3,"Repeat","","Stores inforamtion about separated by.",null,null],[12,"rule","","The rule to separate.",9,null],[12,"optional","","Whether the rule must occur at least once.",9,null],[12,"debug_id","","A debug id to track down the rule generating an error.",9,null],[3,"Select","","Stores information about select.",null,null],[12,"args","","The rules to select from.",10,null],[12,"debug_id","","A debug id to track down the rule generating an error.",10,null],[3,"SeparateBy","","Stores inforamtion about separated by.",null,null],[12,"rule","","The rule to separate.",11,null],[12,"by","","The rule to separate by.",11,null],[12,"optional","","Whether the rule must occur at least once.",11,null],[12,"allow_trail","","Whether the rule can end with separator.",11,null],[12,"debug_id","","A debug id to track down the rule generating an error.",11,null],[3,"Sequence","","Stores information about sequence.",null,null],[12,"args","","The sequential rules.",12,null],[12,"debug_id","","A debug id to track down the rule generating an error.",12,null],[3,"Text","","Stores information about text.",null,null],[12,"allow_empty","","Whether to allow empty string.",13,null],[12,"property","","Which property to set if text is read.",13,null],[12,"debug_id","","A debug id to track down the rule generating an error.",13,null],[3,"Tag","","Stores information about tag.",null,null],[12,"text","","The text to match against.",14,null],[12,"not","","Whether to fail when matching against text.",14,null],[12,"inverted","","Whether to set property to true or false (inverted).",14,null],[12,"property","","Which property to set if tag matches.",14,null],[12,"debug_id","","A debug id to track down the rule generating an error.",14,null],[3,"UntilAny","","Stores information about reading until whitespace or any of some character.",null,null],[12,"any_characters","","The characters to stop at.",15,null],[12,"optional","","Whether empty data is accepted or not.",15,null],[12,"property","","The property to store read text.",15,null],[12,"debug_id","","A debug id to track down the rule generating an error.",15,null],[3,"UntilAnyOrWhitespace","","Stores information about reading until whitespace or any of some character.",null,null],[12,"any_characters","","The characters to stop at.",16,null],[12,"optional","","Whether empty data is accepted or not.",16,null],[12,"property","","The property to store read text.",16,null],[12,"debug_id","","A debug id to track down the rule generating an error.",16,null],[3,"Whitespace","","Stores information about whitespace.",null,null],[12,"optional","","Whether the whitespace is optional or required.",17,null],[12,"debug_id","","A debug id to track down the rule generating an error.",17,null],[4,"Rule","","A rule describes how some section of a document should be parsed.",null,null],[13,"Whitespace","","Read whitespace.",2,null],[13,"Tag","","Match against a tag.",2,null],[13,"UntilAny","","Reads until any character.",2,null],[13,"UntilAnyOrWhitespace","","Read until any character or whitespace.",2,null],[13,"Text","","Read text.",2,null],[13,"Number","","Read number.",2,null],[13,"Select","","Select one of the sub rules.\nIf the first one does not succeed, try another and so on.\nIf all sub rules fail, then the rule fails.",2,null],[13,"Sequence","","Run each sub rule in sequence.\nIf any sub rule fails, the rule fails.",2,null],[13,"SeparateBy","","Repeat rule separated by another rule.",2,null],[13,"Repeat","","Repeat rule.",2,null],[13,"Lines","","Repeat rule separated by one or more lines.",2,null],[13,"Node","","Read node.",2,null],[13,"Optional","","Read optional.",2,null],[5,"parse","","Parses text with rules.",null,{"inputs":[{"name":"syntax"},{"name":"str"},{"name":"vec"}],"output":{"name":"result"}}],[5,"parse_errstr","","Parses text with rules, formatting the error as a `String`.",null,{"inputs":[{"name":"syntax"},{"name":"str"},{"name":"vec"}],"output":{"name":"result"}}],[5,"update_refs","","Updates the references such that they point to each other.",null,{"inputs":[{"name":"syntax"}],"output":null}],[11,"clone","","",5,null],[11,"fmt","","",5,null],[11,"eq","","",5,null],[11,"ne","","",5,null],[11,"parse","","Parses rule separated by one or more lines.\nIgnores lines that only contain whitespace characters.",5,null],[11,"clone","","",6,null],[11,"fmt","","",6,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"parse","","Parses node.",6,null],[11,"clone","","",7,null],[11,"fmt","","",7,null],[11,"eq","","",7,null],[11,"ne","","",7,null],[11,"parse","","Parses number.",7,null],[11,"clone","","",8,null],[11,"fmt","","",8,null],[11,"eq","","",8,null],[11,"ne","","",8,null],[11,"parse","","Parse optional.\nReturns the old state if any sub rule fails.",8,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"eq","","",9,null],[11,"ne","","",9,null],[11,"parse","","Parses rule repeatedly.",9,null],[11,"clone","piston_meta","",2,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"parse","","Parses rule.",2,null],[11,"update_refs","","Updates replacing names with the references.",2,null],[11,"clone","piston_meta::meta_rules","",10,null],[11,"fmt","","",10,null],[11,"eq","","",10,null],[11,"ne","","",10,null],[11,"parse","","Parses select.",10,null],[11,"clone","","",11,null],[11,"fmt","","",11,null],[11,"eq","","",11,null],[11,"ne","","",11,null],[11,"parse","","Parses rule repeatedly separated by another rule.",11,null],[11,"clone","","",12,null],[11,"fmt","","",12,null],[11,"eq","","",12,null],[11,"ne","","",12,null],[11,"parse","","Parses sequence.\nFails if any sub rule fails.",12,null],[11,"clone","","",13,null],[11,"fmt","","",13,null],[11,"eq","","",13,null],[11,"ne","","",13,null],[11,"parse","","Parses text.",13,null],[11,"clone","","",14,null],[11,"fmt","","",14,null],[11,"eq","","",14,null],[11,"ne","","",14,null],[11,"parse","","Parses tag.\nIf the tag is linked to a property,\nthe property will be set.\nIf the meta reader fails setting the property the error is handled.\nIf the token is not linked to any property,\nthe same state will be returned.",14,null],[11,"clone","","",15,null],[11,"fmt","","",15,null],[11,"eq","","",15,null],[11,"ne","","",15,null],[11,"parse","","Parses until whitespace or any specified characters.",15,null],[11,"clone","","",16,null],[11,"fmt","","",16,null],[11,"eq","","",16,null],[11,"ne","","",16,null],[11,"parse","","Parses until whitespace or any specified characters.",16,null],[11,"clone","","",17,null],[11,"fmt","","",17,null],[11,"eq","","",17,null],[11,"ne","","",17,null],[11,"parse","","Parse whitespace.\nIf whitespace is required and no whitespace is found,\nan error will be reported.",17,null],[6,"ParseResult","","A parse result succeeds with a new state,\nplus an optional error to replace other errors if it is deeper.\nThe deepest error is likely the most useful.",null,null],[0,"tokenizer","piston_meta","Tracking tokenizer state.",null,null],[3,"TokenizerState","piston_meta::tokenizer","Stores the number of tokens received.",null,null],[12,"0","","",18,null],[5,"read_data","","Reads meta data.",null,{"inputs":[{"name":"vec"},{"name":"range"},{"name":"tokenizerstate"}],"output":{"name":"tokenizerstate"}}],[11,"clone","","",18,null],[11,"fmt","","",18,null],[11,"partial_cmp","","",18,null],[11,"lt","","",18,null],[11,"le","","",18,null],[11,"gt","","",18,null],[11,"ge","","",18,null],[11,"cmp","","",18,null],[11,"eq","","",18,null],[11,"ne","","",18,null],[11,"new","","Creates a new tokenizer state.",18,{"inputs":[],"output":{"name":"tokenizerstate"}}],[11,"fmt","piston_meta","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"fmt","","",1,null],[11,"new","","Creates a new error handler.",19,{"inputs":[{"name":"str"}],"output":{"name":"parseerrorhandler"}}],[11,"write_msg","","Writes message.",19,null],[11,"write","","Writes error message.",19,null],[11,"error","","Prints error message to standard error.",19,null],[6,"DebugId","","The type of debug id used to track down errors in rules.",null,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"clone","","",3,null],[11,"fmt","","",3,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"new","","Creates a new syntax.",0,{"inputs":[],"output":{"name":"syntax"}}],[11,"push","","Adds a new rule.",0,null]],"paths":[[3,"Syntax"],[4,"ParseError"],[4,"Rule"],[4,"MetaData"],[3,"Convert"],[3,"Lines"],[3,"Node"],[3,"Number"],[3,"Optional"],[3,"Repeat"],[3,"Select"],[3,"SeparateBy"],[3,"Sequence"],[3,"Text"],[3,"Tag"],[3,"UntilAny"],[3,"UntilAnyOrWhitespace"],[3,"Whitespace"],[3,"TokenizerState"],[3,"ParseErrorHandler"]]};
searchIndex["read_token"] = {"doc":"A simple library to read tokens using look ahead","items":[[3,"ReadToken","read_token","Stores the state of parsing.",null,null],[3,"NumberSettings","","The settings for reading numbers.",null,null],[12,"allow_underscore","","Whether to allow underscore in number.",0,null],[4,"ParseStringError","","Contains errors when parsing a string.",null,null],[13,"ExpectedFourHexadecimals","","Expected four hexadecimals, found less characters",1,null],[13,"ExpectedHexadecimal","","Expected character `0-9a-fA-F`",1,null],[13,"ExpectedValidUnicode","","Found four hexadecimals, but not an invalid unicode character",1,null],[13,"ExpectedValidEscapeCharacter","","A character escape `\\x` is invalid",1,null],[4,"ParseNumberError","","Error when parsing number.",null,null],[13,"ExpectedDigits","","The number was empty.",2,null],[13,"Invalid","","The number is of invalid format.",2,null],[13,"OverflowInfinity","","The number overflowed to infinity.",2,null],[13,"OverflowNegInfinity","","The number overflowed to negative infinity.",2,null],[11,"clone","","",3,null],[11,"fmt","","",3,null],[11,"new","","Creates a new `ReadToken`.\nThe offset is in characters.",3,{"inputs":[{"name":"str"},{"name":"usize"}],"output":{"name":"readtoken"}}],[11,"consume","","Consumes n characters.",3,null],[11,"raw_string","","Reads a raw string.",3,null],[11,"lines","","Read lines until closure returns `None`.\nReturns `Ok(range)` of the successful read lines.\nReturns `Err(range)` when expected new line.",3,null],[11,"subtract","","Returns the difference in offset.",3,null],[11,"start","","Returns an empty range at current offset.",3,null],[11,"peek","","Peek a number of characters ahead.",3,null],[11,"tag","","Reads an expected tag, returns character range and new state.\nReturns old state when fail to match tag.",3,null],[11,"until_any_or_whitespace","","Reads a token until any character in string or whitespace.\nReturns `(range, None)` if stopping at whitespace\nor end of characters.\nReturns `(range, Some(x))` if stopping at a character.",3,null],[11,"until_any","","Reads token until any character in string.\nReturns `(new_state, range, None)` if stopping at end of characters.\nReturns `(new_state, range, Some(x))` if stopping at a character.",3,null],[11,"whitespace","","Reads whitespace.",3,null],[11,"string","","Reads string with character escapes.",3,null],[11,"number","","Reads number.",3,null],[11,"parse_string","","Parses string into a real string according to the JSON standard.",3,null],[11,"parse_number","","Parses number from n characters.",3,null],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"eq","","",1,null],[11,"fmt","","",1,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"fmt","","",2,null]],"paths":[[3,"NumberSettings"],[4,"ParseStringError"],[4,"ParseNumberError"],[3,"ReadToken"]]};
searchIndex["range"] = {"doc":"A library for range addressing","items":[[3,"Range","range","A representation of a range",null,null],[12,"offset","","The range offset",0,null],[12,"length","","The range length",0,null],[12,"data","","The data described within the range.",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"hash","","",0,null],[11,"fmt","","",0,null],[11,"new","","Creates a new `Range`",0,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"range"}}],[11,"wrap","","Wraps some data in the range.",0,null],[11,"empty","","Creates an empty range with an offset.",0,{"inputs":[{"name":"usize"}],"output":{"name":"range"}}],[11,"shrink_n","","Shrinks range at both ends with `n` items.",0,null],[11,"shrink","","Shrinks range at both ends with 1 item.",0,null],[11,"intersect","","Intersects a range with another, where ends are excluded.",0,null],[11,"ends_intersect","","Intersects a range with another, where ends are included.",0,null],[11,"is_empty","","Returns true if range is empty",0,null],[11,"next_offset","","Returns the next offset",0,null],[11,"iter","","Returns a range iterator.",0,null],[11,"map","","Maps from some data to another.",0,null],[11,"range","","Returns range information without the data.",0,null],[11,"unwrap","","Unwraps the data.",0,null],[11,"decouple","","Decouples range and data.",0,null],[11,"from","","",0,null]],"paths":[[3,"Range"]]};
initSearch(searchIndex);
